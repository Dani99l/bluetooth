/*******************************************************************************
* File Name: main.c
*
* Version: 1.0
*
* Description:
* Works as the slave(periferical) sensor, connects with the master(server);
* based on example code from cypress -Project 20
*
*******************************************************************************/

#include "main.h"
#include "stdio.h"

int count;
int main()
{       
        start();
        count=0;
        #ifdef LOW_POWER_MODE    
        CYBLE_LP_MODE_T         lpMode;
        CYBLE_BLESS_STATE_T     blessState;
        #endif
       
        char message[100];
        startBLE();
         // UART_UartPutString("\n\r OUT \n\r ");
      while(1){
        
        do {
        HandleBleProcessing();
        CyBle_ProcessEvents();
        } while(CyBle_GetState()!= CYBLE_STATE_CONNECTED);
       
       if( CyBle_GattGetBusStatus() != CYBLE_STACK_STATE_BUSY){
        snprintf(message, 100, "teste%u", count);
        sendtoble(message, strlen(message));   
        count++;
         }
    if (count>10) {
        count=0;
      //CyBle_Stop();
    } 
    if(CyBle_GetState()== CYBLE_STATE_STOPPED) {
        start();
        startBLE();
    }
        
    HandleBleProcessing();
    CyBle_ProcessEvents();
         }
      //  CyBle_Stop();
//        UART_UartPutString("\n\r OUT \n\r ");
//        HandleBleProcessing();
}

// State machine allows to read the sensors, set the ble component and send data to the periferical

void state_machine(){  
     switch(mode){
        
     case START:
        // init interrupts
        //init uart
        
        UART_UartPutString("\n\r START  \n\r ");     
        mode=SENSOR_PACKET;
        break;
        
     case SENSOR_PACKET:
        UART_UartPutString("\n\r SENSOR \n\r ");     
        //get sensor data
        //set a packet to send to central device
        // 1st test with random data
       // Getsensor_data(); //create a packet;
     //  #ifdef PRINT_MESSAGE_LOG   
        //   UART_UartPutString("\n\r After Sensor packet \n\r ");
     //   #endif
        mode=TX;
        break;
        
     case TX:
        // BLE GAP functions
       //check if it possible to transmit
        
        //#ifdef PRINT_MESSAGE_LOG   
        UART_UartPutString("\n\r After TX mode \n\r ");
        //#endif

        mode=RX;
        break;
        
     case RX:
        //check if central device is connected, if not, sum ERROR        
        //receive ACK from central device?
        UART_UartPutString("\n\r RX \n\r ");
        mode=SLEEP;
        break; 
        
     case SLEEP:
        
        //go to sleep mode untill next time to operate! 
        //check sleep time functions
       // sleepMode();
        // #ifdef PRINT_MESSAGE_LOG   
        UART_UartPutString("\n\r After sleep mode \n\r ");
        //#endif
        mode=START;
        break;
     
     default:
        UART_UartPutString("\n\r DEGUB-> Blocked in DEFAULD Switch modes");
        break;
    }
}
        

int Getsensor_data(){
    
    //return a random sensor data;   
    int humidity;
    humidity=50;
    
    return humidity;
}

struct Packet createPacket(){
    // Packet is a buffer with total data that will be sent 
    // It depends on MTU(maximum bytes allowed )
    
    struct Packet Central;
    
    Central.humidity= 0;
    Central.temperature = 1;
    HandleBleProcessing();
    return Central;
}

void startBLE(){
   //This function init the BLE component, this means, BLE STACK 
   // AppCallBack manages the state BLE machine
    
    CyBle_Start(AppCallBack);
    
    
}

void stopBLE(){
    //Stops any proccesing in BLE Stack
    CyBle_Stop();
    
}

/*******************************************************************************
* Function Name: AppCallBack
********************************************************************************
*
* Summary:
*   Call back function for BLE stack to handle BLESS events
*
* Parameters:
*   event       - the event generated by stack
*   eventParam  - the parameters related to the corresponding event
*
* Return:
*   None.
*
*******************************************************************************/
void AppCallBack(uint32 event, void *eventParam)
{   
    CYBLE_GATT_ERR_CODE_T           errorCode;
    CYBLE_GATTS_WRITE_REQ_PARAM_T   *writeReqParam;
    
    switch (event)
    {
        case CYBLE_EVT_STACK_ON:
             UART_UartPutString("\n\r CYBLE_EVT_STACK_ON \n\r ");
            break;
            
        case CYBLE_EVT_GAP_DEVICE_DISCONNECTED:
            UART_UartPutString("\n\r CYBLE_EVT_GAP_DEVICE_DISCONNECTED \n\r ");
            break;
            
        case CYBLE_EVT_GATT_CONNECT_IND:
            UART_UartPutString("\n\r CYBLE_EVT_GATT_CONNECT_IND \n\r ");
            break;
        
        case CYBLE_EVT_GATTS_WRITE_CMD_REQ:
        /** 'Write Command' Request from client device.*/
            UART_UartPutString("\n\r CYBLE_EVT_GATTS_WRITE_CMD_REQ \n\r ");
            HandleUartRxTraffic((CYBLE_GATTS_WRITE_REQ_PARAM_T *) eventParam);
            break;
        
        case CYBLE_EVT_GATTS_XCNHG_MTU_REQ:
            /** 'GATT MTU Exchange Request'*/
            UART_UartPutString("\n\r CYBLE_EVT_GATTS_XCNHG_MTU_REQ \n\r ");
            if(CYBLE_GATT_MTU > ((CYBLE_GATT_XCHG_MTU_PARAM_T *)eventParam)->mtu)
            {
                mtuSize = ((CYBLE_GATT_XCHG_MTU_PARAM_T *)eventParam)->mtu;
            }
            else
            {
                mtuSize = CYBLE_GATT_MTU;
            }
            
            break;
            
        case CYBLE_EVT_GATTS_WRITE_REQ:
            UART_UartPutString("\n\r CYBLE_EVT_GATTS_WRITE_REQ \n\r ");
            writeReqParam = (CYBLE_GATTS_WRITE_REQ_PARAM_T *) eventParam;
            
            if(CYBLE_SERVER_UART_SERVER_UART_TX_DATA_CLIENT_CHARACTERISTIC_CONFIGURATION_DESC_HANDLE == \
                                                                    writeReqParam->handleValPair.attrHandle)
            {
                errorCode = CyBle_GattsWriteAttributeValue(&(writeReqParam->handleValPair), \
                                                0, &cyBle_connHandle, CYBLE_GATT_DB_PEER_INITIATED);
                
                if (CYBLE_GATT_ERR_NONE  == errorCode)
                {
                    CyBle_GattsWriteRsp(cyBle_connHandle);
                    #ifdef PRINT_MESSAGE_LOG   
                        UART_UartPutString("\n\r Notifications enabled\n\r");
                        UART_UartPutString("\n\r Start entering data:\n\r");
                    #endif
                }
            }
            
            break;
        
        default:
            break;
    }
}
    
void start(){
  
    CyGlobalIntEnable;
    
    UART_Start();
    
    UART_UartPutString("\n\r Start peripheral device \n\r ");
}



void sendtoble(uint8* buffer, uint16 size)
{
    //this functions sends data from uart RX and pushes it to the server 

    CYBLE_GATTS_HANDLE_VALUE_NTF_T      uartTxDataNtf;
 
    uartTxDataNtf.value.val  = buffer;
    uartTxDataNtf.value.len  = size;
    uartTxDataNtf.attrHandle = CYBLE_SERVER_UART_SERVER_UART_TX_DATA_CHAR_HANDLE;
  //  UART_UartPutString("\n\r 1 \n\r ");
    
 //   HandleBleProcessing(); //*   Handles the BLE state machine for intiating different procedures during different states of BLESS.
  
    int api;
    do{
     api=CyBle_GattsNotification(cyBle_connHandle, &uartTxDataNtf);
     CyBle_ProcessEvents();
     }while(api!=CYBLE_ERROR_OK);  
  //  HandleBleProcessing(); //*   Handles the BLE state machine for intiating different procedures during different states of BLESS.
    UART_UartPutString(ultoa(count));
}
